(in-package #:low-battery)

(defvar *hero*)

(defclass hero ()
  ((room :initform :main :initarg :room :accessor hero-room)
   (x :initform 0 :initarg :x :accessor x)
   (y :initform 0 :initarg :y :accessor y)
   (charge :initform 9 :initarg :charge :accessor charge)
   (max-charge :initform 9 :initarg :max-charge :accessor max-charge)
   (updates :initform () :accessor updates)
   (last-portal :initform () :initarg last-portal :accessor last-portal)
   (animate :initform nil :accessor animate)))

(defun make-hero ()
  (make-instance 'hero))

(defun fit-camera-to-hero ()
  (alexandria:maxf (x *camera*) (- (x *hero*) (1- (/ (width *camera*) 2))))
  (alexandria:minf (x *camera*) (+ (x *hero*) (1- (/ (width *camera*) 2))))
  (alexandria:maxf (y *camera*) (- (y *hero*) (1- (/ (height *camera*) 2))))
  (alexandria:minf (y *camera*) (+ (y *hero*) (1- (/ (height *camera*) 2)))))

(defun update-hero (&aux (x (x *hero*)) (y (y *hero*)) (cell (cell x y)))
  (serapeum:bcond
    ((alexandria:when-let ((battery (find :battery cell :key #'car)))
       (when (plusp (cdr battery))
         (cdr battery)))
     :=> charge (setf (charge *hero*)
                      (min (+ (charge *hero*) charge)
                           (max-charge *hero*))))
    ((or (member *room* '(:main :home))
         (find :home cell :key #'car)
         (find :portal cell :key #'car))
     (setf (charge *hero*) (max-charge *hero*)))
    ((find :ice cell :key #'car)
     (decf (charge *hero*) 2))
    (t
     (decf (charge *hero*))))
  (alexandria:when-let ((update (find :update cell :key #'car)))
    (unless (cdr update)
      (push (list *room* x y) (updates *hero*))
      (incf (max-charge *hero*))
      (setf (cdr update) t)))
  (when (minusp (charge *hero*))
    (when (last-portal *hero*)
      (portal-to (last-portal *hero*)))))

(defun animated-move (dx dy)
  (let ((animate-clock (sc:make-clock :speed 2 :time-source (game-clock *game*)))
        (x (x *hero*))
        (y (y *hero*)))
    (setf (game-animating *game*)
          (lambda (&aux (v (sc:time animate-clock)))
            (if (>= v 1)
                (progn
                  (setf (game-animating *game*) nil
                        (animate *hero*) nil
                        (x *hero*) (+ x dx)
                        (y *hero*) (+ y dy))
                  (update-hero))
                (setf (x *hero*) (+ x (* dx v))
                      (y *hero*) (+ y (* dy v))
                      (animate *hero*) (list :move v)))
            (fit-camera-to-hero)))))

(defvar *portals-on* nil)

(defun portal-to (ref)
  (setf *portals-on* t)
  (let ((animate-clock (sc:make-clock :speed 1 :time-source (game-clock *game*)))
        (x (* *unit* (- (x *hero*) (- (x *camera*)
                                      (/ (width *camera*) 2)))))
        (y (* *unit* (- (y *hero*) (- (y *camera*)
                                      (/ (height *camera*) 2)))))
        (w (* *unit* (width *camera*)))
        (h (* *unit* (height *camera*))))
    (setf (game-animating *game*)
          (lambda (&aux (v (sc:time animate-clock)))
            (s+:enable-scissor (alexandria:lerp v 0 (- x (/ *unit* 2)))
                               (alexandria:lerp v 0 (- y (/ *unit* 2)))
                               (- (alexandria:lerp v w (+ x (/ *unit* 2)))
                                  (alexandria:lerp v 0 (- x (/ *unit* 2))))
                               (- (alexandria:lerp v h (+ y (/ *unit* 2)))
                                  (alexandria:lerp v 0 (- y (/ *unit* 2)))))
            (when (>= v 1)
              (setf (game-animating *game*)
                    (let ((animate-clock (sc:make-clock :speed 2 :time-source (game-clock *game*))))
                      (lambda (&aux (v (sc:time animate-clock)))
                        (s+:enable-scissor (- x (/ *unit* 2)) (- y (/ *unit* 2)) *unit* *unit*)
                        (setf (animate *hero*) (list :skiss v))
                        (when (>= v 1)
                          (setf (game-animating *game*)
                                (let ((animate-clock (sc:make-clock :speed 4 :time-source (game-clock *game*))))
                                  (lambda (&aux (v (sc:time animate-clock)))
                                    (s+:enable-scissor (alexandria:lerp v (- x (/ *unit* 2)) x)
                                                       (alexandria:lerp v (- y (/ *unit* 2)) y)
                                                       (alexandria:lerp v *unit* 0)
                                                       (alexandria:lerp v *unit* 0))
                                    (when (>= v 1)
                                      (go-to-room (car ref))
                                      (setf (x *camera*) (cadr ref)
                                            (y *camera*) (caddr ref)
                                            (x *hero*) (cadr ref)
                                            (y *hero*) (caddr ref)
                                            x (/ (width *camera*) 2)
                                            y (/ (height *camera*) 2))
                                      (update-hero)
                                      (setf (game-animating *game*)
                                            (let ((animate-clock (sc:make-clock :speed 4 :time-source (game-clock *game*))))
                                              (lambda (&aux (v (sc:time animate-clock)))
                                                (s+:enable-scissor (alexandria:lerp v x (- x (/ *unit* 2)))
                                                                   (alexandria:lerp v y (- y (/ *unit* 2)))
                                                                   (alexandria:lerp v 0 *unit*)
                                                                   (alexandria:lerp v 0 *unit*))
                                                (when (>= v 1)
                                                  (setf (game-animating *game*)
                                                        (let ((animate-clock (sc:make-clock :speed 2 :time-source (game-clock *game*))))
                                                          (lambda (&aux (v (sc:time animate-clock)))
                                                            (s+:enable-scissor (- x (/ *unit* 2)) (- y (/ *unit* 2)) *unit* *unit*)
                                                            (setf (animate *hero*) (list :skiss (- 1 v)))
                                                            (when (>= v 1)
                                                              (setf (animate *hero*) nil)
                                                              (setf (game-animating *game*)
                                                                    (let ((animate-clock (sc:make-clock :speed 2 :time-source (game-clock *game*))))
                                                                      (lambda (&aux (v (sc:time animate-clock)))
                                                                        (when (>= v 1)
                                                                          (setf (game-animating *game*)
                                                                                (let ((animate-clock (sc:make-clock :speed 1 :time-source (game-clock *game*))))
                                                                                  (lambda (&aux (v (sc:time animate-clock)))
                                                                                    (s+:enable-scissor (alexandria:lerp v (- x (/ *unit* 2)) 0)
                                                                                                       (alexandria:lerp v (- y (/ *unit* 2)) 0)
                                                                                                       (- (alexandria:lerp v (+ x (/ *unit* 2)) w)
                                                                                                          (alexandria:lerp v (- x (/ *unit* 2)) 0))
                                                                                                       (- (alexandria:lerp v (+ y (/ *unit* 2)) h)
                                                                                                          (alexandria:lerp v (- y (/ *unit* 2)) 0)))
                                                                                    (when (>= v 1)
                                                                                      (setf (game-animating *game*) nil
                                                                                            *portals-on* nil))))))))))))))))))))))))))))))

(defun to-last-portal ()
  (alexandria:when-let ((portal (last-portal *hero*)))
    (portal-to portal)))

(defun move (dx dy &aux (x (x *hero*)) (y (y *hero*)))
  (when (find :platform (cell (+ x dx) (+ y dy)) :key #'car)
    (animated-move dx dy)))

(defun move-up ()
  (move 0 -1))

(defun move-down ()
  (move 0 1))

(defun move-left ()
  (move -1 0))

(defun move-right ()
  (move 1 0))

(defun interact (&aux (x (x *hero*)) (y (y *hero*)))
  (alexandria:when-let ((portal (find :portal (cell x y) :key #'car)))
    (portal-to (cdr portal))))
